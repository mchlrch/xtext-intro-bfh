/*
 * generated by Xtext 2.14.0
 */
package com.acme.homeautomation.dsl.generator

import com.acme.homeautomation.dsl.harDsl.Device
import com.acme.homeautomation.dsl.harDsl.Rule
import com.acme.homeautomation.dsl.harDsl.State
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import static extension com.acme.homeautomation.dsl.ModelAccess.*

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class HarDslGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		val Iterable<Rule> rules = resource.allContents.filter(Rule).toList
		
		if ( ! rules.empty) {
			val String dslFileName = resource.getURI().lastSegment.toString();
			val String outFileBase = dslFileName.substring(0, dslFileName.lastIndexOf("."));
			
		fsa.generateFile(outFileBase + '.js', generateJavascript(rules))
		}				
	}

	def generateJavascript(Iterable<Rule> rules) '''
		«rules.devicesUsed.inDeterministicOrder
			.map[dev | dev.deviceStateEnumeration]
			.join('\n')»
		
		// device state
		const state = {
			«FOR device:rules.devicesUsed.inDeterministicOrder SEPARATOR ','»
				«device.varName»: «device.states.head.enumValueName»
			«ENDFOR»
		}
		
		function event(sensor) {
		    const oldState = Object.assign({}, state)
		
		    // update device state based on sensor input
		    «FOR state:rules.devicesUsed.inDeterministicOrder.flatMap[dev | dev.states]»
		    if (sensor == «state.enumValueName») state.«state.declaringDevice.varName» = «state.enumValueName»
			«ENDFOR»
		
		    // evaluate rules
		    «FOR rule:rules»
		    if (sensor == «rule.when.enumValueName») state.«rule.then.declaringDevice.varName» = «rule.then.enumValueName»		    
		    «ENDFOR»
		
		    if (stateChange(oldState, state)) return state
		}
		
		function stateChange(s1, s2) {
		    return
		    «FOR device:rules.devicesUsed.inDeterministicOrder SEPARATOR ' || '»
		    	s1.«device.varName» != s2.«device.varName»
		    «ENDFOR»
		}
		
		console.log(`supported states:
			«FOR state:rules.devicesUsed.inDeterministicOrder.flatMap[dev | dev.states]»
			    «state.enumValueName»
			«ENDFOR»
			`);
	'''
	
	def deviceStateEnumeration(Device device) '''
		// device: «device.name»
		const «device.name» = Object.freeze({
			«FOR state:device.states SEPARATOR ','»
			«state.name»: Symbol("«state.name»")
			«ENDFOR»
		})
	'''

	def varName(Device device) {
		return device.name.toFirstLower
	}
	
	def enumValueName(State state) '''«state.declaringDevice.name».«state.name»'''
	
}
